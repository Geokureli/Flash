/* Playtomic ActionScript 3 API-----------------------------------------------------------------------Note:  This requires a Playtomic.com account AND a Parse.com account,you will have to register at Parse and configure the settings in yourPlaytomic dashboard.  Your Parse account and billing are completelyseparate to your Playtomic account.  Parse have native support for agrowing number of libraries, possibly including this: Parse:	https://parse.com/ Documentation is available at:  	https://playtomic.com/api/as3 Support is available at: 	https://playtomic.com/community  	https://playtomic.com/issues 	https://playtomic.com/support has more options if you're a premium user Github repositories: 	https://github.com/playtomicYou may modify this SDK if you wish but be kind to our servers.  Becareful about modifying the analytics stuff as it may give you borked reports.Pull requests are welcome if you spot a bug or know a more efficientway to implement something.Copyright (c) 2011 Playtomic Inc.  Playtomic APIs and SDKs are licensed under the MIT license.  Certain portions may come from 3rd parties and carry their own licensing terms and are referenced where applicable.*/package Playtomic{	public final class Parse 	{		private static var SECTION:String;		private static var SAVE:String;		private static var DELETE:String;		private static var LOAD:String;		private static var FIND:String;				internal static function Initialise(apikey:String):void		{			SECTION = Encode.MD5("parse-" + apikey);			SAVE = Encode.MD5("parse-save-" + apikey);			DELETE = Encode.MD5("parse-delete-" + apikey);			LOAD = Encode.MD5("parse-load-" + apikey);			FIND = Encode.MD5("parse-find-" + apikey);		}						/**		 * Creates or updates an object in your Parse.com database		 * @param	pobject		A ParseObject, if it has an objectId it will update otherwise save		 * @param	callback	Callback function to receive the data:  function(pobject:ParseObject, response:Response)		 */		public static function Save(pobject:PFObject, callback:Function = null):void		{			PRequest.Load(SECTION, SAVE, SaveComplete, callback, ObjectPostData(pobject));		}				/**		 * Processes the response received from the server, returns the data and response to the user's callback		 * @param	callback	The user's callback function		 * @param	postdata	The data that was posted		 * @param	data		The XML returned from the server		 * @param	response	The response from the server		 */		private static function SaveComplete(callback:Function, postdata:Object, data:XML = null, response:Response = null):void		{			if(callback == null)				return;							var obj:XMLList = data["object"];			var item:XML = obj[0];						var pobject:PFObject = new PFObject();			pobject.ObjectId = item["id"];			pobject.ClassName = postdata["classname"];			pobject.Password = postdata["password"];									for(var key:String in postdata)			{				if(key.indexOf("data") == 0)				{										pobject.Data[key.substring(4)] = postdata[key];				}			}						if(response.Success)			{				var object:XMLList = data["object"];				pobject.CreatedAt = DateParse(object["created"]);				pobject.UpdatedAt = DateParse(object["created"]);			}						callback(pobject, response);		}				/**		 * Deletes an object in your Parse.com database		 * @param	pobject		A ParseObject that must include the ObjectId		 * @param	callback	Callback function to receive the data:  function(response:Response)		 */		public static function Delete(pobject:PFObject, callback:Function = null):void		{			PRequest.Load(SECTION, DELETE, DeleteComplete, callback, ObjectPostData(pobject));		}				/**		 * Processes the response received from the server, returns the data and response to the user's callback		 * @param	callback	The user's callback function		 * @param	postdata	The data that was posted		 * @param	data		The XML returned from the server		 * @param	response	The response from the server		 */		private static function DeleteComplete(callback:Function, postdata:Object, data:XML = null, response:Response = null):void		{			if(callback == null)				return;			callback(response);			data = data; // just to hide unused var warning			postdata = postdata;		}				/**		 * Loads a specific object from your Parse.com database		 * @param	pobject		A ParseObject that must include the ObjectId and className		 * @param	callback	Callback function to receive the data:  function(pobject:ParseObject, response:Response)		 */		public static function Load(pobjectid:String, classname:String, callback:Function = null):void		{			var pobject:PFObject = new PFObject();			pobject.ObjectId = pobjectid;			pobject.ClassName = classname;						PRequest.Load(SECTION, LOAD, LoadComplete, callback, ObjectPostData(pobject));		}				/**		 * Processes the response received from the server, returns the data and response to the user's callback		 * @param	callback	The user's callback function		 * @param	postdata	The data that was posted		 * @param	data		The XML returned from the server		 * @param	response	The response from the server		 */		private static function LoadComplete(callback:Function, postdata:Object, data:XML = null, response:Response = null):void		{			if(callback == null)				return;							var pobject:PFObject = new PFObject();			pobject.ObjectId = postdata["objectid"];			pobject.ClassName = postdata["classname"];							if(response.Success)			{				var object:XMLList = data["object"];				pobject.CreatedAt = DateParse(object["created"]);				pobject.UpdatedAt = DateParse(object["updated"]);								if(object.contains("fields"))				{					var fields:XMLList = object["fields"];										for each(var field:XML in fields.children())					{						pobject[field.name] = field.text();					}				}			}						callback(pobject, response);		}				/**		 * Finds objects matching the criteria in your ParseQuery		 * @param	pquery		A ParseQuery object		 * @param	callback	Callback function to receive the data:  function(objects:Array, response:Response)		 */		public static function Find(pquery:PFQuery, callback:Function = null):void		{			var postdata:Object = new Object();			postdata["classname"] = pquery.ClassName;			postdata["limit"] = pquery.Limit;			postdata["order"] = pquery.Order != null && pquery.Order != "" ? pquery.Order : "created_at";						for(var key:String in pquery.WhereData)			{				postdata["data" + key] = pquery.WhereData[key];			}						PRequest.Load(SECTION, FIND, FindComplete, callback, postdata);		}				/**		 * Processes the response received from the server, returns the data and response to the user's callback		 * @param	callback	The user's callback function		 * @param	postdata	The data that was posted		 * @param	data		The XML returned from the server		 * @param	response	The response from the server		 */		private static function FindComplete(callback:Function, postdata:Object, data:XML = null, response:Response = null):void		{			if(callback == null)				return;							var objs:Array = new Array();						if(response.Success)			{				var objects:XMLList = data["objects"];								for each(var object:XML in objects.children())				{									var pobject:PFObject = new PFObject();					pobject.ObjectId = object["id"];					pobject.CreatedAt = DateParse(object["created"]);					pobject.UpdatedAt = DateParse(object["updated"]);										if(object.contains("fields"))					{						var fields:XMLList = object["fields"];												for each(var field:XML in fields.children())						{							pobject[field.name] = field.text();						}					}														objs.push(pobject);				}			}						callback(objs, response);			postdata = postdata;		}					/**		 * Turns a ParseObject into data to be POST'd for saving, finding 		 * @param	pobject		The ParseObject		 */			private static function ObjectPostData(pobject:PFObject):Object		{			var postobject:Object = new Object();			postobject["classname"] = pobject.ClassName;			postobject["id"] = (pobject.ObjectId == null ? "" : pobject.ObjectId);			postobject["password"] = (pobject.Password == null ? "" : pobject.Password);						for(var key:String in pobject.Data)				postobject["data" + key] = pobject.Data[key];							return postobject;		}				/**		 * Converts the server's MM/dd/yyyy hh:mm:ss into a Flash Date		 * @param	date		The date from the XML		 */			private static function DateParse(date:String):Date		{			var parts:Array = date.split(" ");			var dateparts:Array = (parts[0] as String).split("/");			var timeparts:Array = (parts[1] as String).split(":");			var day:int = int(dateparts[1]);			var month:int = int(dateparts[0]);			var year:int = int(dateparts[2]);			var hours:int = int(timeparts[0]);			var minutes:int = int(timeparts[1]);			var seconds:int = int(timeparts[2]);			return new Date(Date.UTC(year, month, day, hours, minutes, seconds));		}	}}