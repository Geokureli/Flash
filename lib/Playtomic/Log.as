/* Playtomic ActionScript 3 API----------------------------------------------------------------------- Documentation is available at:  	https://playtomic.com/api/as3 Support is available at: 	https://playtomic.com/community  	https://playtomic.com/issues 	https://playtomic.com/support has more options if you're a premium user Github repositories: 	https://github.com/playtomicYou may modify this SDK if you wish but be kind to our servers.  Becareful about modifying the analytics stuff as it may give you borked reports.Pull requests are welcome if you spot a bug or know a more efficientway to implement something.Copyright (c) 2011 Playtomic Inc.  Playtomic APIs and SDKs are licensed under the MIT license.  Certain portions may come from 3rd parties and carry their own licensing terms and are referenced where applicable.*/package Playtomic{	import flash.display.LoaderInfo;	import flash.events.ErrorEvent;	import flash.events.TimerEvent;	import flash.events.UncaughtErrorEvent;	import flash.external.ExternalInterface;	import flash.net.SharedObject;	import flash.system.Security;	import flash.utils.Timer;	public final class Log	{		// API settings		private static var Enabled:Boolean = false;		private static var Queue:Boolean = true;				// SWF settings		internal static var SWFID:int = 0;		internal static var GUID:String = "";		internal static var SourceUrl:String;		internal static var BaseUrl:String;			// play timer, goal tracking etc		private static var Cookie:SharedObject;		internal static var LogQueue:LogRequest;		private static const PingF:Timer = new Timer(1000);		private static var Pings:int = 0;		private static var Plays:int = 0;					private static var Frozen:Boolean = false;		private static var FrozenQueue:Array = new Array();		// unique, logged metrics		private static var Customs:Array = new Array();		private static var LevelCounters:Array = new Array();		private static var LevelAverages:Array = new Array();		private static var LevelRangeds:Array = new Array();				// parameterized events and other premium features		internal static var UseSSL:Boolean = false;		internal static var PEventsEnabled:Boolean = false;		internal static var PData:Object = {};		internal static var PersistantParams:Object = {};		internal static var PTime:int = 0;				/**		 * Sets the API to use SSL-only for all communication		 */		public static function SetSSL():void		{			UseSSL = true;			trace("You are now using SSL for your api requests.  This feature is for premium users only, if your account is not premium the data you send will be ignored.");		}				/**		 * Sets the referrer		 */		public static function SetReferrer(ref:String):void		{			PRequest.SendReferrer(ref);					}		/**		 * Logs a view and initializes the API.  You must do this first before anything else!		 * @param	swfid		Your game id from the Playtomic dashboard		 * @param	guid		Your game guid from the Playtomic dashboard		 * @param	apikey		Your secret API key from the Playtomic dashboard		 * @param	defaulturl	Should be root.loaderInfo.loaderURL or some other default url value to be used if we can't detect the page		 */		public static function View(swfid:int = 0, guid:String = "", apikey:String = "", loader:LoaderInfo = null):void		{			if(!loader) {				defaulturl = apikey;				apikey = "";				trace("Warning: It looks like you are using the Log.View method from the old version of the API.");				trace("Please update your Log.View call to use the new structure: ");				trace("Log.View(swfid, guid, apikey, root.loaderInfo.loaderURL);");				trace("You can get or create your API key from your game's settings page");			}						if(SWFID > 0)				return;			SWFID = swfid;			GUID = guid;			Enabled = true;			if((SWFID == 0 || GUID == ""))			{				Enabled = false;				return;			}						var defaulturl:String = loader.loaderURL;			SourceUrl = GetUrl(defaulturl);			if(SourceUrl == null || SourceUrl == "")			{				Enabled = false;				return;			}						BaseUrl = SourceUrl.split("://")[1];			BaseUrl = BaseUrl.substring(0, BaseUrl.indexOf("/"));			Parse.Initialise(apikey);			GeoIP.Initialise(apikey);			Data.Initialise(apikey);			Leaderboards.Initialise(apikey);			GameVars.Initialise(apikey);			PlayerLevels.Initialise(apikey);			PRequest.Initialise();						LogQueue = LogRequest.Create();			Cookie = SharedObject.getLocal("playtomic");						// Load the security context			Security.loadPolicyFile((UseSSL ? "https://g" : "http://g") + guid + ".api.playtomic.com/crossdomain.xml");									// Check the URL is http / https			if(defaulturl.indexOf("http://") != 0 && defaulturl.indexOf("https://") != 0) 			{				// Sandbox exceptions for testing				if(Security.sandboxType != "localWithNetwork" && Security.sandboxType != "localTrusted" && Security.sandboxType != "remote")				{					Enabled = false;					return;				}			}			// Log the view (first or repeat visitor)			var views:int = GetCookie("views");			Send("v/" + (views + 1), true);			// Start the play timer			PingF.addEventListener(TimerEvent.TIMER, PingServer);			PingF.start();						// exception catching			//	trace("adding exception catching: " + UncaughtErrorEvent.UNCAUGHT_ERROR);			//	loader.uncaughtErrorEvents.addEventListener(UncaughtErrorEvent.UNCAUGHT_ERROR, LogException);						// PEvents			if(!PEventsEnabled)				return;			PData.source = BaseUrl;			PData.views = views + 1;			PData.time = 0;			PData.eventnum = 0;			PData.location = "initialize";			PData.api = "flash";			PData.apiversion = "3.48";			PData.params = {};						SetSession();				SendPEvent();		}				/*private static function LogException(e:UncaughtErrorEvent):void		{			trace("EXCEPTION: ");			trace(e.toString());			e.preventDefault()		}*/				/**		 * Sets user defined session information.  Leave parameters empty strings to use default values		 * @param	sessionid	Your own session id		 * @param	referredby	The ad or campaign or other source this visitor came by		 * @param	invitedby	The invitation that led to the player joining your game		 */		private static function SetSessionInfo(sessionid:String = "", referredby:String = "", invitedby:String = ""):void		{			if(sessionid != null && sessionid != "")			{				SaveCookieS("sessionid", sessionid);				PData.sessionid = sessionid;			}						if(referredby != null && referredby != "")			{				SaveCookieS("referredby", referredby);				PData.referredby = referredby;			}						if(invitedby != null && invitedby != "")			{				SaveCookieS("invitedby", invitedby);				PData.invitedby = invitedby;			}		}				/**		 * Sets the player session up if it hasn't already been		 */		private static function SetSession():void		{			if(!PData.session)			{				var csession:String = GetCookieS("session");				if(csession != "")				{					PData.session = csession;				}				else				{					PData.session = Encode.MD5(SessionID.Create() + SessionID.Create());					SaveCookieS("session", PData.session);				}			}						if(!PData.invitedby)			{				PData.invitedby = GetCookieS("invitedby");			}						if(!PData.referredby)			{				PData.referredby = GetCookieS("referredby");			}		}				/**		 * Logs an event with parameters		 * @param	params		Any parameters you wish to include with the event such as gender, how they found your game, etc		 * @param	location	The player's current location (eg main menu, level 1)		 */		private static function PEvent(params:Object, location:String = null):void		{			if(location != null)			{				PData.locationbefore = PData.location;				PData.location = location;			}						PData.timebefore = PData.time;			PData.time = PTime;			PData.eventnum++;			PData.params = params;			SendPEvent();		}				/**		 * Logs a transaction in a PEvent		 * @param	params		Any parameters you wish to include		 * @param	location	The player's current location		 * @param	transactions	Array of transactions: {item: string, quantity: int, price: number, any other properties you want}		 */		private static function PTransaction(params:Object, location:String, transactions:Array):void		{			var nparams:Object = {};						for(var x:String in params)				nparams[x] = params[x];						var total:Number = 0;						for(var i:int=0; i<transactions.length; i++)			{				if(!transactions[i].hasOwnProperty("item"))				{					trace("** PEVENT ERROR ** Transaction is missing 'item'.\nThe transactions array must be {item: 'name', quantity: int, price: number, ... }");					return;				}								if(!transactions[i].hasOwnProperty("quantity"))				{					trace("** PEVENT ERROR ** Transaction is missing 'quantity'.\nThe transactions array must be {item: 'name', quantity: int, price: number, ... }");					return;				}								if(!transactions[i].hasOwnProperty("price"))				{					trace("** PEVENT ERROR ** Transaction is missing 'price'.\nThe transactions array must be {item: 'name', quantity: int, price: number, ... }");					return;				}								total += transactions[i].price;			}						nparams.transactions = transactions;			nparams.total = total;			PData.transaction = true;			PEvent(nparams, location);			delete(PData.transaction);		}				/**		 * Logs an invitation in a PEvent		 * @param	params		Any parameters you wish to include		 * @param	location	The player's current location		 * @param	invitations	Array of friend id's invited, from Facebook or other		 */		private static function PInvitation(params:Object, location:String, invitations:Array):void		{			var nparams:Object = {};						for(var x:String in params)				nparams[x] = params[x];						nparams.invitations = invitations;			nparams.total = invitations.length;			PData.invitation = true;			PEvent(nparams, location);			delete(PData.invitation);		}				/**		 * Merges persistant parameters with event parameters and sends		 */		private static function SendPEvent():void		{			for(var x:String in PersistantParams)				PData.params[x] = PersistantParams[x];						PRequest.SendPEvent(PData);		}				/**		 * Increases the number of views successfully logged 		 */		internal static function IncreaseViews():void		{			var views:int = GetCookie("views");			views++;			SaveCookie("views", views);		}				/**		 * Increases the number of plays successfully logged 		 */		internal static function IncreasePlays():void		{			Plays++;		}		/**		 * Logs a play.  Call this when the user begins an actual game (eg clicks play button)		 */		public static function Play():void		{									if(!Enabled)				return;			LevelCounters = new Array();			LevelAverages = new Array();			LevelRangeds = new Array();							Send("p/" + (Plays + 1), true);		}		/**		 * Increases the play time and triggers events being sent		 */		private static function PingServer(e:TimerEvent):void		{								if(!Enabled)				return;						PTime++;						if(PTime == 60)			{				Pings = 1;				Send("t/y/1", true);			}			else if(PTime > 60 && PTime % 30 == 0)			{				Pings++;				Send("t/n/" + Pings, true);			}		}				/**		 * Logs a custom metric which can be used to track how many times something happens in your game.		 * @param	name		The metric name		 * @param	group		Optional group used in reports		 * @param	unique		Only count a metric one single time per view		 */		public static function CustomMetric(name:String, group:String = null, unique:Boolean = false):void		{					if(!Enabled)				return;			if(group == null)				group = "";			if(unique)			{				if(Customs.indexOf(name) > -1)					return;				Customs.push(name);			}						Send("c/" + Clean(name) + "/" + Clean(group));		}		/**		 * Logs a level counter metric which can be used to track how many times something occurs in levels in your game.		 * @param	name		The metric name		 * @param	level		The level number as an integer or name as a string		 * @param	unique		Only count a metric one single time per play		 */		public static function LevelCounterMetric(name:String, level:*, unique:Boolean = false):void		{					if(!Enabled)				return;			if(unique)			{				var key:String = name + "." + String(level);								if(LevelCounters.indexOf(key) > -1)					return;				LevelCounters.push(key);			}						Send("lc/" + Clean(name) + "/" + Clean(level));		}				/**		 * Logs a level ranged metric which can be used to track how many times a certain value is achieved in levels in your game.		 * @param	name		The metric name		 * @param	level		The level number as an integer or name as a string		 * @param	value		The value being tracked		 * @param	unique		Only count a metric one single time per play		 */		public static function LevelRangedMetric(name:String, level:*, value:int, unique:Boolean = false):void		{						if(!Enabled)				return;			if(unique)			{				var key:String = name + "." + String(level) + "." + value.toString();								if(LevelRangeds.indexOf(key) > -1)					return;				LevelRangeds.push(key);			}						Send("lr/" + Clean(name) + "/" + Clean(level) + "/" + value);		}		/**		 * Logs a level average metric which can be used to track the min, max, average and total values for an event.		 * @param	name		The metric name		 * @param	level		The level number as an integer or name as a string		 * @param	value		The value being added		 * @param	unique		Only count a metric one single time per play		 */		public static function LevelAverageMetric(name:String, level:*, value:int, unique:Boolean = false):void		{			if(!Enabled)				return;			if(unique)			{				var key:String = name + "." + String(level);								if(LevelAverages.indexOf(key) > -1)					return;				LevelAverages.push(key);			}						Send("la/" + Clean(name) + "/" + Clean(level) + "/" + value);		}		/**		 * Logs the link results, internal use only.  The correct use is Link.Open(...)		 * @param	url		The url that was opened		 * @param	name	The name for the url		 * @param	group	The group for the url 		 * @param	unique	Increase uniques by this value		 * @param	total	Increase totals by this value		 * @param	fail	Increase fails by this value		 */		internal static function Link(url:String, name:String, group:String, unique:int, total:int, fail:int):void		{			if(!Enabled)				return;						Send("l/" + Clean(name) + "/" + Clean(group) + "/" + Clean(url) + "/" + unique + "/" + total + "/" + fail);		}		/**		 * Logs a heatmap which allows you to visualize where some event occurs.		 * @param	metric		The metric you are tracking (eg clicks)		 * @param	heatmap		The heatmap (the one you upload images for)		 * @param	x			The x coordinate		 * @param	y			The y coordinate		 */		public static function Heatmap(metric:String, heatmap:String, x:int, y:int):void		{			if(!Enabled)				return;						Send("h/" + Clean(metric) + "/" + Clean(heatmap) + "/" + x + "/" + y);		}		/**		 * Not yet implemented :(		 */		internal static function Funnel(name:String, step:String, stepnum:int):void		{			if(!Enabled)				return;						Send("f/" + Clean(name) + "/" + Clean(step) + "/" + stepnum);		}		/**		 * Logs a start of a player level, internal use only.  The correct use is PlayerLevels.LogStart(...);		 * @param	levelid		The player level id		 */		internal static function PlayerLevelStart(levelid:String):void		{			if(!Enabled)				return;						Send("pls/" + levelid);		}		/**		 * Logs a win on a player level, internal use only.  The correct use is PlayerLevels.LogWin(...);		 * @param	levelid		The player level id		 */		internal static function PlayerLevelWin(levelid:String):void		{			if(!Enabled)				return;						Send("plw/" + levelid);		}		/**		 * Logs a quit on a player level, internal use only.  The correct use is PlayerLevels.LogQuit(...);		 * @param	levelid		The player level id		 */		internal static function PlayerLevelQuit(levelid:String):void		{			if(!Enabled)				return;						Send("plq/" + levelid);		}				/**		 * Logs a flag on a player level, internal use only.  The correct use is PlayerLevels.Flag(...);		 * @param	levelid		The player level id		 */		internal static function PlayerLevelFlag(levelid:String):void		{			if(!Enabled)				return;						Send("plf/" + levelid);		}				/**		 * Logs a retry on a player level, internal use only.  The correct use is PlayerLevels.LogRetry(...);		 * @param	levelid		The player level id		 */		internal static function PlayerLevelRetry(levelid:String):void		{			if(!Enabled)				return;						Send("plr/" + levelid);		}				/**		 * Freezes the API so analytics events are queued but not sent		 */		public static function Freeze():void		{			Frozen = true;		}		/**		 * Unfreezes the API and sends any queued events		 */		public static function UnFreeze():void		{			if(!Enabled)				return;						Frozen = false;			LogQueue.MassQueue(FrozenQueue);		}		/**		 * Forces the API to send any unsent data now		 */		public static function ForceSend():void		{			if(!Enabled)			  	return;						if(LogQueue == null)			  	LogQueue = LogRequest.Create();			LogQueue.Send();			LogQueue = LogRequest.Create();						if(FrozenQueue.length > 0)				LogQueue.MassQueue(FrozenQueue);		}				/**		 * Adds an event and if ready or a view or not queuing, sends it		 * @param	s	The event as an ev/xx string		 * @param	view	If it's a view or not		 */		private static function Send(s:String, view:Boolean = false):void		{			if(Frozen)			{				FrozenQueue.push(s);				return;			}						LogQueue.Queue(s);			if(LogQueue.ready || view || !Queue)			{				LogQueue.Send();				LogQueue = LogRequest.Create();			}		}				/**		 * Cleans a piece of text of reserved characters		 * @param	s	The string to be cleaned		 */		private static function Clean(s:String):String		{			while(s.indexOf("/") > -1)				s = s.replace("/", "\\");							while(s.indexOf("~") > -1)				s = s.replace("~", "-");											return escape(s);		}			/**		 * Gets a cookie value		 * @param	n	The key (views, plays)		 */		private static function GetCookie(n:String):int		{			if(Cookie.data[n] == undefined)			{				return 0;			}			else			{				return int(Cookie.data[n]);			}		}				private static function GetCookieS(n:String):String		{			if(Cookie.data[n] == undefined)			{				return "";			}			else			{				return Cookie.data[n];			}		}				/**		 * Saves a cookie value		 * @param	n	The key (views, plays)		 * @param	v	The value		 */		private static function SaveCookie(n:String, v:int):void		{			Cookie.data[n] = v.toString();						try			{				Cookie.flush();			}			catch(s:Error)			{						}		}					private static function SaveCookieS(n:String, v:String):void		{			Cookie.data[n] = v.toString();						try			{				Cookie.flush();			}			catch(s:Error)			{							}		}		/**		 * Attempts to detect the page url		 * @param	defaulturl		The fallback url if page cannot be detected		 */		private static function GetUrl(defaulturl:String):String		{			var url:String;						if(ExternalInterface.available)			{				try				{					url = String(ExternalInterface.call("window.location.href.toString"));				}				catch(s:Error)				{					url = defaulturl;				}			}			else if(defaulturl.indexOf("http://") == 0 || defaulturl.indexOf("https://") == 0)			{				url = defaulturl;			}			if(url == null  || url == "" || url == "null")			{				url = "http://localhost/";			}						if(url.indexOf("http://") != 0 && url.indexOf("https://") != 0)				url = "http://localhost/";			return url;		}	}}